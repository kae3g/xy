const std = @import("std");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsWithAllocator(allocator);
    defer args.deinit();

    _ = args.next(); // skip executable name

    const maybe_input = args.next();
    if (maybe_input) |arg0| {
        if (std.mem.eql(u8, arg0, "--help")) {
            printUsage();
            return;
        }
        const output = args.next() orelse {
            stderr("error: missing output path\n");
            printUsage();
            return;
        };
        try run(allocator, arg0, output);
        return;
    }

    // Interactive mode
    stdout("Interactive mode engaged.\n");
    const input_path = try promptForPath(allocator, "Enter markdown input path (.md): ");
    defer allocator.free(input_path);

    const output_path = try promptForPath(allocator, "Enter zig output path (.zig): ");
    defer allocator.free(output_path);

    try run(allocator, input_path, output_path);
}

fn run(allocator: std.mem.Allocator, input_path: []const u8, output_path: []const u8) !void {
    try ensureExtension(input_path, ".md");
    try ensureCursorPrefix(input_path);
    try ensureExtension(output_path, ".zig");

    const cwd = std.fs.cwd();
    const content = try cwd.readFileAlloc(allocator, input_path, std.math.maxInt(usize));
    defer allocator.free(content);

    const marker = "**Cursor**";
    var index: usize = 0;
    var count: usize = 0;
    while (std.mem.indexOfPos(u8, content, index, marker)) |pos| {
        count += 1;
        index = pos + marker.len;
    }

    const file = try cwd.createFile(output_path, .{ .truncate = true });
    defer file.close();

    try file.writeAll("// Generated by extract_outputs.zig\n");
    var buffer: [64]u8 = undefined;
    const line = try std.fmt.bufPrint(&buffer, "pub const cursor_output_count: usize = {d};\n", .{count});
    try file.writeAll(line);

    stdout("Extraction complete.\n");
    std.debug.print("Input: {s}\nOutput: {s}\nOccurrences: {d}\n", .{ input_path, output_path, count });
}

fn ensureExtension(path: []const u8, ext: []const u8) !void {
    if (!std.mem.endsWith(u8, path, ext)) {
        std.debug.print("error: expected path ending with {s}: {s}\n", .{ ext, path });
        return error.InvalidExtension;
    }
}

fn promptForPath(allocator: std.mem.Allocator, prompt: []const u8) ![]u8 {
    stdout(prompt);
    const stdin_file = std.fs.File.stdin();

    var line = std.ArrayListUnmanaged(u8){};
    defer line.deinit(allocator);

    var buf: [1]u8 = undefined;
    var got_any = false;
    while (true) {
        const n = try std.posix.read(stdin_file.handle, buf[0..]);
        if (n == 0) break;
        got_any = true;
        if (buf[0] == '\n') break;
        try line.append(allocator, buf[0]);
    }
    if (!got_any and line.items.len == 0) return error.NoInput;

    const trimmed = std.mem.trim(u8, line.items, " \r\n\t");
    if (trimmed.len == 0) return error.EmptyPath;

    const copy = try allocator.alloc(u8, trimmed.len);
    std.mem.copyForwards(u8, copy, trimmed);
    return copy;
}

fn stdout(msg: []const u8) void {
    std.debug.print("{s}", .{msg});
}

fn stderr(msg: []const u8) void {
    std.debug.print("{s}", .{msg});
}

fn printUsage() void {
    stdout(
        "usage: extract_outputs <input.md> <output.zig>\n" ++
            "       extract_outputs            # interactive mode\n",
    );
}

fn ensureCursorPrefix(path: []const u8) !void {
    const base = std.fs.path.basename(path);
    if (!std.mem.startsWith(u8, base, "cursor")) {
        std.debug.print("error: markdown export must begin with 'cursor': {s}\n", .{path});
        return error.InvalidPrefix;
    }
}
